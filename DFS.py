# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z54iB8JjA8uBqF_V2IIzw5zYmKeIRgT3
"""

def is_safe(maze, x, y):
    return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0

def dfs(maze, x, y, path):
    # Base case: if we reach the bottom-right corner
    if x == len(maze) - 1 and y == len(maze[0]) - 1:
        path.append((x, y))
        return True

    # Check if the current position is safe
    if is_safe(maze, x, y):
        # Mark the cell as visited
        maze[x][y] = 2
        path.append((x, y))

        # Explore neighbors (down, up, right, left)
        if (dfs(maze, x + 1, y, path) or
            dfs(maze, x - 1, y, path) or
            dfs(maze, x, y + 1, path) or
            dfs(maze, x, y - 1, path)):
            return True

        # Backtrack: unmark the cell
        path.pop()
        maze[x][y] = 0

    return False

def solve_maze(maze):
    path = []
    if dfs(maze, 0, 0, path):
        return path
    else:
        return "No path found"

maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 1, 1, 0]
]

solution = solve_maze(maze)
print("Path to solution:", solution)